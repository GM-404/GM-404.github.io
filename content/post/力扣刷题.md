
---
title: 力扣刷题
date:  2025-09-29 
lastmod: 2025-10-10
---

# 基础知识

## 链表代码实现
```c++

#include <iostream>
#include <stdexcept>
class MyLinkedList {
private:
    struct Node {
        int val;
        Node* next;
        Node* prev;
        Node(int value) : val(value), next(nullptr), prev(nullptr) {}
    };

    Node* head; // 虚拟头节点
    Node* tail; // 虚拟尾节点
    int size;

    // 辅助函数：查找索引处的节点（用于插入和遍历）
    // 当 index = size 时，返回 tail 节点
    Node* getNode(int index) const {
        // **优化：从头尾中较近的一端开始遍历**
        Node* p;
        if (index < size / 2) {
            // 从头开始：head->next 是 index 0 对应的节点
            p = head->next;
            for (int i = 0; i < index; i++) {
                p = p->next;
            }
        } else {
            // 从尾开始：tail->prev 是 index size-1 对应的节点
            p = tail;
            for (int i = 0; i < (size - index); i++) {
                p = p->prev;
            }
        }
        return p;
    }

    // 检查 index 索引位置是否可以存在元素 [0, size-1]
    bool isElementIndex(int index) const { 
        return index >= 0 && index < size; 
    }

    // 检查 index 索引位置是否可以添加元素 [0, size]
    bool isPositionIndex(int index) const {
        return index >= 0 && index <= size;
    }

public:
    MyLinkedList() {
        head = new Node(0);
        tail = new Node(0);
        head->next = tail;
        tail->prev = head;
        size = 0;
    }

    // 析构函数（补充：用于释放内存，解决内存泄漏）
    ~MyLinkedList() {
        Node* curr = head;
        while (curr != nullptr) {
            Node* next = curr->next;
            delete curr;
            curr = next;
        }
        head = nullptr;
        tail = nullptr;
        size = 0;
    }

    // --- 增加 ---
    void addAtHead(int val) {
        // 利用 addAtIndex(0, val) 实现最简洁
        addAtIndex(0, val);
    }

    void addAtTail(int val) {
        // 利用 addAtIndex(size, val) 实现最简洁
        addAtIndex(size, val);
    }

    void addAtIndex(int index, int val) {
        // 核心修改：检查位置索引的有效性
        if (!isPositionIndex(index)) {
            // 题目要求：如果 index 比长度更大，该节点将不会插入
            // 这里我们直接返回，不抛出异常
            return;
        }
        
        // 找到插入位置的节点 (node)，它将成为新节点 x 的 next
        // 当 index=size 时，node 刚好是 tail
        Node* node = getNode(index); 
        Node* prev_node = node->prev; 
        Node* x = new Node(val);

        // 插入操作： prev_node <-> x <-> node
        x->prev = prev_node;
        x->next = node;
        node->prev = x;
        prev_node->next = x;

        // 更新数量
        size++;
    }

    // --- 查 ---
    int get(int index) {
        // 核心修改：检查元素索引的有效性
        if (!isElementIndex(index)) {
            return -1; // 题目要求：下标无效，返回 -1
        }
        
        // 找到 index 对应的 Node
        Node* p = getNode(index);
        
        // 由于上面已经检查了索引，p 必然是有效的实际元素节点，不是 tail 或 nullptr
        return p->val;
    }

    // --- 删 ---
    void deleteAtIndex(int index) {
        // 核心修改：检查元素索引的有效性
        if (!isElementIndex(index)) {
            return; // 题目要求：如果下标无效，不执行删除
        }
        
        // 找到 index 对应的 Node (x)，它必然是有效的实际元素节点
        Node* x = getNode(index);
        Node* prev = x->prev;
        Node* next = x->next;
        
        // 绕过 x
        prev->next = next;
        next->prev = prev;

        // 对删去的节点清空内存
        delete x;

        // 更新数量
        size--;
    }
};

```

## 哈希表
### 哈希表核心原理
哈希表可以理解为一个加强版的数组。
数组可以通过索引在 O(1) 的时间复杂度内查找到对应元素，索引是一个非负整数。

哈希表是类似的，可以通过 key 在O(1) 的时间复杂度内查找到这个 key 对应的 value。key 的类型可以是数字、字符串等多种类型。

怎么做的？特别简单，哈希表的底层实现就是一个数组（我们不妨称之为 table）。它先把这个 key 通过一个哈希函数（我们不妨称之为 hash）转化成数组里面的索引，然后增删查改操作和数组基本相同

**简单理解就是把键当成数组里面的元素，对键操作就算是对值操作了**
key 是唯一的，value 可以重复
哈希函数的作用是把任意长度的输入（key）转化成固定长度的输出（索引）。

所以，增删查改的方法中都会用到哈希函数来计算索引，如果你设计的这个哈希函数复杂度是 O(N)，那么哈希表的增删查改性能就会退化成 O(N)，所以说这个函数的性能很关键。

**所以并不是提到哈希增删改查就是O(1)的复杂度，要看你设计的哈希函数是怎么样的**

```c++
#include <iostream>
#include <list>
```